export = example;
declare class example {
    static VERSION: string;
    static after(n: any, func: any): any;
    static all(collection: any, callback: any, thisArg: any): any;
    static any(collection: any, callback: any, thisArg: any): any;
    static assign(object: any, source: any, guard: any, ...args: any[]): any;
    static at(collection: any, ...args: any[]): any;
    static bind(func: any, thisArg: any, ...args: any[]): any;
    static bindAll(object: any, ...args: any[]): any;
    static bindKey(object: any, key: any, ...args: any[]): any;
    static clone(value: any, deep: any, callback: any, thisArg: any, stackA: any, stackB: any): any;
    static cloneDeep(value: any, callback: any, thisArg: any): any;
    static collect(collection: any, callback: any, thisArg: any): any;
    static compact(array: any): any;
    static compose(...args: any[]): any;
    static contains(collection: any, target: any, fromIndex: any): any;
    static countBy(collection: any, callback: any, thisArg: any): any;
    static debounce(func: any, wait: any, immediate: any): any;
    static defaults(object: any, source: any, guard: any, ...args: any[]): any;
    static defer(...args: any[]): any;
    static delay(func: any, wait: any, ...args: any[]): any;
    static detect(collection: any, callback: any, thisArg: any): any;
    static difference(array: any, ...args: any[]): any;
    static drop(array: any, callback: any, thisArg: any): any;
    static each(collection: any, callback: any, thisArg: any): any;
    static escape(string: any): any;
    static every(collection: any, callback: any, thisArg: any): any;
    static extend(object: any, source: any, guard: any, ...args: any[]): any;
    static filter(collection: any, callback: any, thisArg: any): any;
    static find(collection: any, callback: any, thisArg: any): any;
    static first(array: any, callback: any, thisArg: any): any;
    static flatten(array: any, shallow: any): any;
    static foldl(collection: any, callback: any, accumulator: any, thisArg: any, ...args: any[]): any;
    static foldr(collection: any, callback: any, accumulator: any, thisArg: any, ...args: any[]): any;
    static forEach(collection: any, callback: any, thisArg: any): any;
    static forIn(collection: any, callback: any, thisArg: any): any;
    static forOwn(collection: any, callback: any, thisArg: any): any;
    static functions(object: any): any;
    static groupBy(collection: any, callback: any, thisArg: any): any;
    static has(object: any, property: any): any;
    static head(array: any, callback: any, thisArg: any): any;
    static identity(value: any): any;
    static include(collection: any, target: any, fromIndex: any): any;
    static indexOf(array: any, value: any, fromIndex: any): any;
    static initial(array: any, callback: any, thisArg: any): any;
    static inject(collection: any, callback: any, accumulator: any, thisArg: any, ...args: any[]): any;
    static intersection(array: any, ...args: any[]): any;
    static invert(object: any): any;
    static invoke(collection: any, methodName: any, ...args: any[]): any;
    static isArguments(value: any): any;
    static isArray(p0: any): any;
    static isBoolean(value: any): any;
    static isDate(value: any): any;
    static isElement(value: any): any;
    static isEmpty(value: any): any;
    static isEqual(a: any, b: any, callback: any, thisArg: any, stackA: any, stackB: any): any;
    static isFinite(value: any): any;
    static isFunction(value: any): any;
    static isNaN(value: any): any;
    static isNull(value: any): any;
    static isNumber(value: any): any;
    static isObject(value: any): any;
    static isPlainObject(value: any): any;
    static isRegExp(value: any): any;
    static isString(value: any): any;
    static isUndefined(value: any): any;
    static keys(object: any): any;
    static last(array: any, callback: any, thisArg: any): any;
    static lastIndexOf(array: any, value: any, fromIndex: any): any;
    static map(collection: any, callback: any, thisArg: any): any;
    static max(collection: any, callback: any, thisArg: any): any;
    static memoize(func: any, resolver: any): any;
    static merge(object: any, source: any, deepIndicator: any, ...args: any[]): any;
    static methods(object: any): any;
    static min(collection: any, callback: any, thisArg: any): any;
    static mixin(object: any): void;
    static noConflict(): any;
    static object(keys: any, values: any): any;
    static omit(object: any, callback: any, thisArg: any, ...args: any[]): any;
    static once(func: any): any;
    static pairs(object: any): any;
    static partial(func: any, ...args: any[]): any;
    static partialRight(func: any, ...args: any[]): any;
    static pick(object: any, callback: any, thisArg: any, ...args: any[]): any;
    static pluck(collection: any, callback: any, thisArg: any): any;
    static random(min: any, max: any): any;
    static range(start: any, end: any, step: any): any;
    static reduce(collection: any, callback: any, accumulator: any, thisArg: any, ...args: any[]): any;
    static reduceRight(collection: any, callback: any, accumulator: any, thisArg: any, ...args: any[]): any;
    static reject(collection: any, callback: any, thisArg: any): any;
    static rest(array: any, callback: any, thisArg: any): any;
    static result(object: any, property: any): any;
    static select(collection: any, callback: any, thisArg: any): any;
    static shuffle(collection: any): any;
    static size(collection: any): any;
    static some(collection: any, callback: any, thisArg: any): any;
    static sortBy(collection: any, callback: any, thisArg: any): any;
    static sortedIndex(array: any, value: any, callback: any, thisArg: any): any;
    static tail(array: any, callback: any, thisArg: any): any;
    static take(array: any, callback: any, thisArg: any): any;
    static tap(value: any, interceptor: any): any;
    static template(text: any, data: any, options: any): any;
    static templateSettings: {
        escape: RegExp;
        evaluate: RegExp;
        imports: {};
        interpolate: RegExp;
        variable: string;
    };
    static throttle(func: any, wait: any): any;
    static times(n: any, callback: any, thisArg: any): any;
    static toArray(collection: any): any;
    static unescape(string: any): any;
    static union(...args: any[]): any;
    static uniq(array: any, isSorted: any, callback: any, thisArg: any): any;
    static unique(array: any, isSorted: any, callback: any, thisArg: any): any;
    static uniqueId(prefix: any): any;
    static values(object: any): any;
    static where(collection: any, callback: any, thisArg: any): any;
    static without(array: any, ...args: any[]): any;
    static wrap(value: any, wrapper: any): any;
    static zip(array: any, ...args: any[]): any;
    constructor(value: any);
    after(...args: any[]): any;
    all(...args: any[]): any;
    any(...args: any[]): any;
    assign(...args: any[]): any;
    at(...args: any[]): any;
    bind(...args: any[]): any;
    bindAll(...args: any[]): any;
    bindKey(...args: any[]): any;
    clone(...args: any[]): any;
    cloneDeep(...args: any[]): any;
    collect(...args: any[]): any;
    compact(...args: any[]): any;
    compose(...args: any[]): any;
    concat(...args: any[]): any;
    contains(...args: any[]): any;
    countBy(...args: any[]): any;
    debounce(...args: any[]): any;
    defaults(...args: any[]): any;
    defer(...args: any[]): any;
    delay(...args: any[]): any;
    detect(...args: any[]): any;
    difference(...args: any[]): any;
    drop(...args: any[]): any;
    each(...args: any[]): any;
    escape(...args: any[]): any;
    every(...args: any[]): any;
    extend(...args: any[]): any;
    filter(...args: any[]): any;
    find(...args: any[]): any;
    first(callback: any, thisArg: any): any;
    flatten(...args: any[]): any;
    foldl(...args: any[]): any;
    foldr(...args: any[]): any;
    forEach(...args: any[]): any;
    forIn(...args: any[]): any;
    forOwn(...args: any[]): any;
    functions(...args: any[]): any;
    groupBy(...args: any[]): any;
    has(...args: any[]): any;
    head(callback: any, thisArg: any): any;
    identity(...args: any[]): any;
    include(...args: any[]): any;
    indexOf(...args: any[]): any;
    initial(...args: any[]): any;
    inject(...args: any[]): any;
    intersection(...args: any[]): any;
    invert(...args: any[]): any;
    invoke(...args: any[]): any;
    isArguments(...args: any[]): any;
    isArray(...args: any[]): any;
    isBoolean(...args: any[]): any;
    isDate(...args: any[]): any;
    isElement(...args: any[]): any;
    isEmpty(...args: any[]): any;
    isEqual(...args: any[]): any;
    isFinite(...args: any[]): any;
    isFunction(...args: any[]): any;
    isNaN(...args: any[]): any;
    isNull(...args: any[]): any;
    isNumber(...args: any[]): any;
    isObject(...args: any[]): any;
    isPlainObject(...args: any[]): any;
    isRegExp(...args: any[]): any;
    isString(...args: any[]): any;
    isUndefined(...args: any[]): any;
    join(...args: any[]): any;
    keys(...args: any[]): any;
    last(callback: any, thisArg: any): any;
    lastIndexOf(...args: any[]): any;
    map(...args: any[]): any;
    max(...args: any[]): any;
    memoize(...args: any[]): any;
    merge(...args: any[]): any;
    methods(...args: any[]): any;
    min(...args: any[]): any;
    mixin(...args: any[]): any;
    noConflict(...args: any[]): any;
    object(...args: any[]): any;
    omit(...args: any[]): any;
    once(...args: any[]): any;
    pairs(...args: any[]): any;
    partial(...args: any[]): any;
    partialRight(...args: any[]): any;
    pick(...args: any[]): any;
    pluck(...args: any[]): any;
    pop(...args: any[]): any;
    push(...args: any[]): any;
    random(...args: any[]): any;
    range(...args: any[]): any;
    reduce(...args: any[]): any;
    reduceRight(...args: any[]): any;
    reject(...args: any[]): any;
    rest(...args: any[]): any;
    result(...args: any[]): any;
    reverse(...args: any[]): any;
    select(...args: any[]): any;
    shift(...args: any[]): any;
    shuffle(...args: any[]): any;
    size(...args: any[]): any;
    slice(...args: any[]): any;
    some(...args: any[]): any;
    sort(...args: any[]): any;
    sortBy(...args: any[]): any;
    sortedIndex(...args: any[]): any;
    splice(...args: any[]): any;
    tail(...args: any[]): any;
    take(callback: any, thisArg: any): any;
    tap(...args: any[]): any;
    template(...args: any[]): any;
    templateSettings(...args: any[]): any;
    throttle(...args: any[]): any;
    times(...args: any[]): any;
    toArray(...args: any[]): any;
    unescape(...args: any[]): any;
    union(...args: any[]): any;
    uniq(...args: any[]): any;
    unique(...args: any[]): any;
    uniqueId(...args: any[]): any;
    unshift(...args: any[]): any;
    value(): any;
    valueOf(): any;
    values(...args: any[]): any;
    where(...args: any[]): any;
    without(...args: any[]): any;
    wrap(...args: any[]): any;
    zip(...args: any[]): any;
}